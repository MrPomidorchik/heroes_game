# Алгоритмы и структуры данных. Итоговый проект

## Описание проекта

В данном проекте реализованны ключевые алгоритмы для пошаговой стратегии.
Реализация выполнялась в рамках учебного задания по дисциплине «Алгоритмы и структуры данных» и направлена на закрепление навыков анализа алгоритмической сложности и применения классических алгоритмов на практической задаче.

Проект состоит из реализации четырёх интерфейсов, предоставленных библиотекой `heroes_task_lib`:

- `GeneratePreset` — генерация армии противника;
- `SimulateBattle` — симуляция пошагового боя;
- `SuitableForAttackUnitsFinder` — определение доступных для атаки целей;
- `UnitTargetPathFinder` — поиск кратчайшего пути между юнитами на игровом поле.

Реализация подключается к готовой игре путём подмены `obf.jar`.

---

## Реализованные модули и анализ алгоритмической сложности

### 1. Генерация армии противника

**Класс:** `GeneratePresetImpl`

Метод отвечает за создание армии компьютера с учётом следующих ограничений:

- суммарная стоимость армии не превышает `maxPoints`;
- количество юнитов каждого типа не больше 11;
- предпочтение отдаётся наиболее эффективным юнитам;
- расположение юнитов каждый раз меняется.

Сначала типы юнитов сортируются по эффективности.  
После этого армия заполняется жадным образом.  
В конце юниты случайным образом размещаются на стороне противника на игровом поле.

#### Алгоритмическая сложность

Пусть:

- `n` — количество типов юнитов;
- `m` — количество юнитов в армии.

Этапы работы:

- сортировка типов юнитов: `O(n log n)`;
- добавление юнитов в армию: `O(n · m)`;
- случайное размещение на поле фиксированного размера: `O(1)`.

Итоговая сложность: O(n · m)

---

### 2. Симуляция боя

**Класс:** `SimulateBattleImpl`

Метод реализует пошаговый бой между армией игрока и армией компьютера.

На каждом ходе:

- юниты сортируются по убыванию силы атаки;
- выполняются атаки по очереди;
- погибшие юниты исключаются из дальнейших ходов;
- после каждого удара выводится лог боя.

Очередь ходов пересчитывается при изменении состава армий.

#### Алгоритмическая сложность

Пусть `n` — общее количество юнитов в бою.

- формирование очереди ходов: `O(n log n)`;
- количество ходов в худшем случае — `O(n²)`.

Итоговая сложность: O(n² log n)

---

### 3. Определение доступных целей для атаки

**Класс:** `SuitableForAttackUnitsFinderImpl`

Метод определяет, какие юниты противника доступны для атаки.  
Юнит считается доступным, если он не закрыт союзным юнитом по направлению атаки.

Для каждого ряда проверяются координаты `y` юнитов и исключаются перекрытые цели.

#### Алгоритмическая сложность

Пусть `n` — количество юнитов в ряду.  
Так как рядов всего три, сложность линейная.

Итоговая сложность: O(n)

---

### 4. Поиск кратчайшего пути

**Класс:** `UnitTargetPathFinderImpl`

Метод ищет кратчайший путь между атакующим и атакуемым юнитом на поле размером 27×21.  
Используется алгоритм поиска в ширину (BFS), так как все переходы имеют одинаковую стоимость, а диагональное движение разрешено.

#### Алгоритмическая сложность

Поиск выполняется по всей сетке игрового поля.

Итоговая сложность: O(n · m)

где `n = 27`, `m = 21`.

Эта сложность лучше, чем указанная в задании.

---

## Используемые библиотеки

В проекте используются:

- стандартная библиотека Java;
- библиотека задания `heroes_task_lib`.

Сторонние внешние библиотеки не применяются.

---

## Как запустить проект

Для проверки работы алгоритмов необходимо:

1. Поместить файл `obf.jar` в директорию `heroes/jars`, заменив оригинальный файл.
2. Перейти в директорию `heroes`.
3. Запустить игру командой:

```bash
java -jar "Heroes Battle-1.0.0.jar"
```
